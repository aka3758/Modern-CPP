# 第二章 语言可用性的强化——模板

C++的模板被称作C++的黑魔法，甚至可以独立作为一门新的语言来进行使用。

模板的哲学在于一切能够在编译期处理的问题全部都丢到编译期进行处理，仅在运行时处理那些最核心的动态服务，进而大幅度优化性能。

## 外部模板

传统C++中，模板只有在使用时才会被编译器实例化。只要在每个编译单元(文件)中遇到了被完整定义的模板，都会实例化。这就产生了重复实例化而导致编译时间增加。并且，我们没有办法通知编译器不要触发模板的实例化。

C++11 引入了外部模板，扩充了原来的强制编译器在特性位置实例化模板的语法，使我们能够显示的通知编译器何时进行模板的实例化。如下代码：

```C++
template class vector<bool>;  //强行实例化
extern template class vector<double>;  //不在当前文件中实例化模板
```

## 尖括号">"

在传统C++的编译器中，>>一律被当作右移运算符来进行处理。但是，很容易就会出现下面的代码：

```C++
vector<vector<int>> matrix;
```

传统 C++ 编译器下不能通过编译，而从 C++11 开始，连续右尖括号是合法的。甚至，可以写出如下代码：

```C++
template<bool T>
class MagicType
{
    bool magic = T;
};

vector<MagicType<(1 < 2)>> magic;  //合法，但是非常难看，不建议
```

有些代码合法，但是从可读性的角度是不合理的，要杜绝。除非为了性能考虑，必须写成可读性不好的代码，但是这种情况非常少。

## 类型别名模板

模板是用来产生类型的。这句话应该是 C++ 模板的核心了。

在传统 C++ 中，typedef 可以为类型定义一个新的名称，但是没有办法为模板定义一个新的名称。因为模板不是类型。如下代码：

```C++
template<typename T, typename U>
class MagicType
{
public:
    T dark;
    U magic;
};

typedef MagicType<vector<T>, string> FakeDarkMagic;  //不合法
```

通常，使用 typedef 定义别名的语法是：typedef 原名称 新名称；但是对函数指针的别名定义的语法却不一样。

C++11 使用 using 引入了下面的写法：

```C++
typedef int (*process)(void *);
using NewProcess = int(*)(void *);  //和上面的效果一样

using TrueDarkMagic = MagicType<vector<T>, string>;  //合法
```

## 变长参数模板

在 C++11 之前，无论是类模板还是函数模板，都只能是一组固定的模板参数。C++11 允许任意个数任意类型的模板参数，同时也不需要在定义时将参数的个数确定。

```C++
template<typename... Ts> class Magic
{
    //这块代码书上的没有定义，跑不了，添加一个空定义
};

class Magic<int,
            vector<int>,
            map<string, vector<int>>> darkMagic;

class Magic<> nothing;  //参数个数为 0 也是可以的
```

如果不希望产生的模板参数为 0 ，可以手动定义至少任意数量的模板参数，如下代码：

```C++
template<typename T1, typename T2, typename... Ts> class Magic
{

};

class Magic<int, int, string, string> darkMagic1;  //可以正常调用

class Magic<int> darkMagic2;  //错误，参数过少
```

## 变长函数参数包

变长参数模板可以直接用到模板函数上。比如传统 C++ 的 printf 函数虽然也能进行不定参数的调用，但是并非类型安全，我们可以自己定义一个，如下代码：

```C++
template<typename... Args>
void printf(const string &str, Args... args)
{
    //个人还是喜欢分行写，这样可以避免单行代码过长，造成阅读困难
}
```


