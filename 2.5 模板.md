# 第二章 语言可用性的强化——模板

C++的模板被称作C++的黑魔法，甚至可以独立作为一门新的语言来进行使用。

模板的哲学在于一切能够在编译期处理的问题全部都丢到编译期进行处理，仅在运行时处理那些最核心的动态服务，进而大幅度优化性能。

## 外部模板

传统C++中，模板只有在使用时才会被编译器实例化。只要在每个编译单元(文件)中遇到了被完整定义的模板，都会实例化。这就产生了重复实例化而导致编译时间增加。并且，我们没有办法通知编译器不要触发模板的实例化。

C++11 引入了外部模板，扩充了原来的强制编译器在特性位置实例化模板的语法，使我们能够显示的通知编译器何时进行模板的实例化。如下代码：

```C++
template class vector<bool>;  //强行实例化
extern template class vector<double>;  //不在当前文件中实例化模板
```

## 尖括号">"

在传统C++的编译器中，>>一律被当作右移运算符来进行处理。但是，很容易就会出现下面的代码：

```C++
vector<vector<int>> matrix;
```

传统 C++ 编译器下不能通过编译，而从 C++11 开始，连续右尖括号是合法的。甚至，可以写出如下代码：

```C++
template<bool T>
class MagicType
{
    bool magic = T;
};

vector<MagicType<(1 < 2)>> magic;  //合法，但是非常难看，不建议
```

有些代码合法，但是从可读性的角度是不合理的，要杜绝。除非为了性能考虑，必须写成可读性不好的代码，但是这种情况非常少。

## 类型别名模板

模板是用来产生类型的。这句话应该是 C++ 模板的核心了。

在传统 C++ 中，typedef 可以为类型定义一个新的名称，但是没有办法为模板定义一个新的名称。因为模板不是类型。如下代码：

```C++
template<typename T, typename U>
class MagicType
{
public:
    T dark;
    U magic;
};

typedef MagicType<vector<T>, string> FakeDarkMagic;  //不合法
```

通常，使用 typedef 定义别名的语法是：typedef 原名称 新名称；但是对函数指针的别名定义的语法却不一样。

C++11 使用 using 引入了下面的写法：

```C++
typedef int (*process)(void *);
using NewProcess = int(*)(void *);  //和上面的效果一样

using TrueDarkMagic = MagicType<vector<T>, string>;  //合法
```
