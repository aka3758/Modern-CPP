# 2.6 面向对象

## 委托构造

C++11 引入了委托构造的概念。通过初始化列表的方式(注意：不是列表初始化)，可以使得同一个类中的一个构造函数调用另一个构造函数，从而达到简化代码的目的。如下代码：

```C++
#include <iostream>
class Base
{
public:
    Base()
    {
        value = 1;
    }

    Base(int value) : Base()  //委托构造函数
    {
        value2 = value;
    }

    int value1;
    int value2;
};

int main()
{
    Base b(2);
    cout << b.value1 << endl;  //输出 1
    cout << b.value2 << endl;  //输出 2
}
```

### 使用委托构造函数的注意事项

1.初始化列表中只能包含目标构造函数，不能包含对成员变量的初始化，只能在函数体中对指定的成员变量进行赋值操作。

2.不要形成委托环，会导致编译错误。如下代码：

```C++
class Foo
{
public:
    Foo(int i) : Foo('c')
    {
         type = i; 
    }

    Foo(char c) : Foo(1) 
    { 
        name = c; 
    }
    //Foo(int) 和 Foo(chsr) 循环嵌套，编译器不会报错，但是无法通过编译

private:
    int type;
    char name;
};

```

一定要注意循环嵌套的问题。因为这个问题编译器不会给报告任何东西。如果有编程经验的就知道，这种错误有多难找。空指针、野指针、数组越界都属于编译器不给错误提示的错误。

如果违反了第一条，编译器会给报错。一旦违反了，还是比较容易找到的。但是，作为一个合格的开发者，不能老是指着编译器给你报错。

## 继承构造

我感觉书上这里写的有问题。书上说使用传统 C++ 的构造函数，需要将每个参数都传递，会导致效率低下。但是，据我了解，继承构造函数并没有效率上的提升。

而且，我感觉整个关于语言可用性的第二章，都没有涉及到效率上的提升。

传统 C++ 中，类为了完成基类初始化工作，需要在自己的构造函数的初始化列表中调用父类的构造函数，从而完成构造函数的传递。

如果父类有多个构造函数（函数重载），子类也需要编写多个构造函数来分别实现对父类构造函数的调用。这无疑多出了许多的麻烦。

C++11 利用 using 关键字，引入了继承构造函数的概念。如下代码：

```C++
#include <iostream>
using namespace std;

class Base
{
public:
    Base()
    {
        value1 = 1;
        value2 = 2;
    }

    Base(int num) : value1(num), value2(num)
    {

    }

    int value1;
    int value2;
};

class Subclass : public Base
{
public:
    using Base::Base;  //继承构造
};

int main()
{
    Subclass s(3);
    cout << s.value1 << endl;  //输出 3
    cout << s.value2 << endl;  //输出 3
    return 0;
}
```

使用继承构造函数还有一个优点：如果一个继承构造函数未被使用，则编译器不会为其产生真正的函数代码。可能这就是书上说有效率提升的原因，这个优点也符合 C++ 的一贯原则。不为你不需要的东西付出代价。

### 使用继承构造函数的注意事项

1.继承构造函数无法初始化派生类数据成员。继承构造函数只是为了初始化基类，如果派生类有自己的成员变量，需要另外初始化。

2.基类构造函数拥有默认参数会产生多个版本的构造函数，而且继承构造函数无法继承基类构造函数的默认参数，所有使用带有默认参数构造函数的基类时就必须小心。如下代码：

```C++
class A
{
public:
    A(int a = 3, double b = 4.0) : m_a(a), m_b(b) {}
    void display() { cout << m_a << " " << m_b << endl; }

private:
    int m_a;
    double m_b;
};

class B : public A
{
public:
    using A::A;
};

/*
A中的构造函数就会有以下几个版本：

A()
A(int)
A(int, double)
A(const A &)

B中的继承构造函数将会包含如下几个版本：

B()
B(int)
B(int, double)
B(const B &)
*/
```

3.在多继承时，继承构造函数会出现"冲突"的情况。因为多个基类中的部分构造函数可能导致派生类中的继承构造函数的函数名、参数相同。如下代码：

```C++
class A
{
public:
    A(int i) {}
};

class B
{
public:
    B(int i) {}
};

class C : public A, public B
{
    using A::A;
    using B::B; // 编译错误，重复定义C(int)
    C(int i) : A(i), B(i) {} // 用显式定义构造函数方式解决冲突
    //如果没有上面的那行代码会编译报错
};
```

4.如果基类构造函数被声明为私有，或者通过虚继承产生的派生类，那么就不能在派生类中定义继承构造函数。

5.一旦使用继承构造函数，编译器就不再为派生类生成默认构造函数了。

C++ 构造函数的问题一直比较复杂。我觉得，复杂的主要原因就是 C++ 的偶像包袱，你不必为你不需要的东西付出代价。只有需要调用不同的构造函数去实例化不同的对象，才会在运行期间提升效率。

关于构造函数，我们需要了解 C++ 的面向对象的机制，还有 C++ 编译运行的机制。但是，这个问题好像比较复杂，很难深入浅出的回答。这里推荐一本书，也是属于 C++ 众多必读书籍中的一本。书名叫做《深度探索C++对象模型》。
