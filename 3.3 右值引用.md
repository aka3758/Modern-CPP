# 3.3 右值引用

我感觉，右值引用绝对是现代 C++ 中最重要的特性。解决了很多历史遗留问题。

右值引用消除了诸如 std::vector、std::string 等容器额外的开销，也使得函数对象容器 std::function 成为了可能。

## 左值、右值、纯右值、将亡值

我们先详细区分一些现代 C++ 中的各种值

### 左值

英文是 lvalue，表示的是存储在内存中、有明确存储地址（可寻址）的数据。

### 右值

英文是 rvalue，表示的是那些可以提供数据值的数据（不一定可以寻址，例如存储于寄存器中的数据）。

C++11 中为了引入强大的右值引用，将右值的概念进行了进一步的划分，分为纯右值、将亡值。

#### 纯右值

英文是 prvalue，纯粹的右值。要么是纯粹的字面量，如 10, true等；要么是求职结果相当于字面量或临时对象，如 1 + 2。非引用返回的临时变量、运算表达式产生的临时变量、原始字面量、Lambda 表达式都属于纯右值。

#### 将亡值

英文是 xvalue，C++11 引入右值引用而提出的概念。表示即将被销毁、却能够被移动的值。

### C++之父对于值的理解

B神原话：

For all the values, there were only two independent properties:

"has identity" – i.e. an address, a pointer, the user can determine whether two copies are identical, etc.

"can be moved from" – i.e. we are allowed to leave to source of a "copy" in some indeterminate, but valid state.
There are four possible composition:

iM: has identity and cannot be moved from (defined as lvalue)
im: has identity and can be moved from (defined as xvalue)
Im: does not have identity and can be moved from (defined as prvalue)
IM: doesn't have identity and cannot be moved (他认为这种情况在 C++ 中是没有用的)

大概意思就是，C++ 中的值有两个属性，一个是身份，一个是可移动。

身份：能够确定某个表达式是否和另一个表达式指涉同一个实体，比如指针，名称之类的东西。

可移动：能够被移动构造函数、移动赋值操作符或者其它实现移动语义的重载函数绑定。

lvalue：所谓的左值，有身份，不能被移动

xvalue：所谓的将亡值，有身份，可移动

pvalue：所谓的纯右值，没有身份，可移动

另一种情况大神认为在 C++ 中没有意义。

如果想要学习更多的关于 C++ 值的知识，可以参考网站：[cppreference.com](https://en.cppreference.com/mwiki/index.php?title=cpp/language/value_category&oldid=85137)

## 右值引用和左值引用

要拿到一个 xvalue，就需要用到右值引用：T &&，其中 T 是类型。右值引用的声明让这个临时值的生命周期得以延长、只要变量活着，那么 xvalue 将继续存活。

C++11 提供了 std::move 这个方法讲左值参数无条件的转换为右值。如下代码：

```C++
#include <iostream>
#include <functional>
#include <string>

using namespace std;

void reference(string &str)
{
    cout << "lvalue" << endl;
}

void reference(string &&str)
{
    cout << "rvalue" << endl;
}

int main()
{
    string lv1 = "string,";  //lv1 是一个 lvalue
    //string&& r1 = lv1;  //非法，rvalue 引用不能引用 lvalue
    string &&rv1 = move(lv1);  //合法，std::move 可以将 lvalue 转移为 rvalue
    cout << rv1 << endl;  //string

    const string &lv2 = lv1 + lv1;  //合法，常量 lvalue 引用能够延长临时变量的生命周期
    //lv2 += "Test";  //非法，常量引用无法被修改
    cout << lv2 << endl;  //string,string

    string &&rv2 = lv1 + lv2;  //合法，rvalue 引用延长临时对象生命周期
    rv2 += "Test";  //合法，非常量引用能够修改临时变量
    cout << rv2 << endl;  //string,string,string

    reference(rv2);  //输出 lvalue
    return 0;
}
```

注意，rv2 虽然引用了一个右值，但是由于它是一个引用，所以 rv2 依然是一个左值。

这里有一个比较有意思的事，先看下面代码：

```C++
#include <iostream>

using namespace std;

int main()
{
    //int &a = move(1);  //不合法，非常量 lvalue 引用只能绑定到 lvalue
    //这里说一下，move(1) 和 1 是一样的，就是说 move() 对 rvalue 操作没有实际意义
    const int &b = 1;  //合法，常量 lvalue 引用允许绑定 rvalue
    cout << b << endl;

    return 0;
}
```

书上写的没理解上去，下面说一下个人看法。

我的理解，引用是一段内存地址的别名。

第一个问题，非常量 lvalue 引用不能绑定 rvalue。我的看法是，从内存的角度，1 和 move(1) 都是在常量区的(这里关于 C++ 的分区一直各有各的说法)，总之就是一段不可能更改的内存。对这段内存的所有更改操作都应该不合法。

按照我的理解，第二个问题：常量 lvalue 引用允许绑定 rvalue 就好解释了。常量引用本身就不可以修改，绑定到一个 rvalue 没有问题。

还有，书上的这段代码是跑不过的，代码如下：

```C++
void increase(int &v)
{
    v++;
}

void foo()
{
    double s = 1;
    int t = 1;
    increase(s);  //不合法

}
```

按照我的理解，不是像书上说的那样会诞生一个所谓的临时值保存 s 的值，而是直接报错。原因就是 int 的内存规则和 double 的内存规则不一样。没有办法用 int 内存的别名去操作 double 的内存。

关于这块的理解，完全是个人理解，和书上的角度完全是不一样的。如果有人有更好的理解，欢迎评论区里讨论。
