# 第五章 智能指针与内存管理

## 5.1 RAII 与引用计数

引用计数的目的是为了防止内存泄漏产生的。

基本思路：对于动态分配的对象，进行引用计数，每当增加一次对同一个对象的引用，那么引用计数就会增加一次；每删除一次引用，引用计数就会减一；当一个对象的引用计数减为零的时候，就自动删除指向的堆内存。

传统 C++ 中，一定记得手动开辟，手动释放，总不是最佳实践。通常做法是对于一个对象而言，我们在构造函数的时候申请空间，而在析构函数的时候释放空间，这也就是常说的RAII 资源获取即初始化技术。

凡事都会有例外，我们也有时需要将对象在自由存储上分配的要求。在传统 C++ 中，我们只好使用 new 和 delete 去对资源进行操作。

C++11 引入了智能指针的概念，运用了引用计数，让程序要不再需要关心手动释放内存。

这些智能指针包括 std::shared_ptr/std::unique_ptr/std::weak_ptr，使用它们需要包含头文件 \<memory>。

注意：引用计数不是垃圾回收，引用计数能够尽快回收不再使用的对象，同时在过程中也不会长时间等待，更能够清晰明确的表明资源的生命周期。

## 5.2 std::shared_ptr

std::shared_ptr 是一种智能指针，它能够记录多少个 shared_ptr 共同指向一个对象，从而消除显示调用 delete，当引用计数为零时就会将对象自动删除。

但是使用 std::shared_ptr 仍然需要使用 new 来调用，这使得代码出现了某种程度上的不对称。

std::make_shared 就能够用来消除显式的使用 new，所以 std::make_shared 会分配创建传入参数中的对象，并返回这个对象类型的 std::shared_ptr 指针。代码如下：

```C++
#include <iostream>
#include <memory>

using namespace std;

void foo(shared_ptr<int> i)
{
    (*i)++;
}

int main()
{
    //auto pointer = new int(10);  //非法，无法将 int* 转换为 std::shared_ptr<int>

    auto pointer = make_shared<int>(10);

    foo(pointer);
    cout << *pointer << endl;
    //shared_ptr 智能指针将会在离开作用域之前被销毁

    return 0;
}
```

std::shared_ptr 可以通过 get() 方法来获取原始指针，通过 reset() 来减少一个引用计数，并通过 use_count() 来查看一个对象的引用计数。代码如下：

```C++
auto pointer = make_shared<int>(10);
auto pointer2 = pointer;  //引用计数 +1
auto pointer3 = pointer;  //引用计数 +1
int *p = pointer.get();  //这样不会增加引用计数
cout << "pointer.use_count() = " << pointer.use_count() << endl;  //输出 3
cout << "pointer2.use_count() = " << pointer2.use_count() << endl;  //输出 3
cout << "pointer3.use_count() = " << pointer3.use_count() << endl;  //输出 3

pointer2.reset();
cout << "reset pointer2: " << endl;
cout << "pointer.use_count() = " << pointer.use_count() << endl;  //输出 2
cout << "pointer2.use_count() = " << pointer2.use_count() << endl;  //输出 0，pointer2 已经 reset
cout << "pointer3.use_count() = " << pointer3.use_count() << endl;  //输出 2

pointer3.reset();
cout << "reset pointer2: " << endl;
cout << "pointer.use_count() = " << pointer.use_count() << endl;  //输出 2
cout << "pointer2.use_count() = " << pointer2.use_count() << endl;  //输出 0
cout << "pointer3.use_count() = " << pointer3.use_count() << endl;  //输出 0，pointer3 已经 reset
```

## 5.3 std::unique_ptr

std::unique_ptr 是一种独占的智能指针，它禁止其他智能指针与其共享同一个对象，从而保证代码的安全：
