# 第二章 语言可用性的强化

## 2.1 常量

### nullptr

目的是为了代替NULL。传统C++会把NULL、0是为一种东西，这取决于编译器如何定义NULL。有些编译器会定义为((void)* 0)，有些会直接定义为0.

C++不允许直接将void *隐式转换到其他类型。如果编译器尝试把NULL定义为((void)* 0)，如下代码：

```C++
char *ch = NULL;
```

由于C++没有 void * 的隐式转换，只好将NULL定义为0。表面上是解决了当前问题，但是这样做会产生重载混乱的新问题，如下代码：

```C++
void foo(char*);
void foo(int);
...
foo(NULL);  //这个函数会调用 foo(int)，不符合直觉，很麻烦
```

C++11引入了nullptr关键字，专门用来区分空指针、0。nullptr的类型为nullptr_t，能够隐式的转换成任何指针或成员指针的类型，也能和它们进行相等或者不相等比较。

所以，作为新时代的C++程序员，请养成使用nullptr的习惯。

### constexpr

C++中数组的长度必须是一个常量表达式，你可以以前通过如下代码也可以定义一个数组：

```c++
const int len = 10;
int arr[len] = { 0 };
```

上面的代码可能在大部分编译器上可以跑，但是其实在C++中这是非法的。如果用古老一点的编译器，是会报错的，但是现在的编译器大部分都做了优化，其实这一点非常的不好。

C++11引入了 constexpr关键字，让用户显示的声明函数或对象构造函数在编译期会成为常量表达式。而且，constexpr可以修饰递归，如下代码：

```C++
constexpr int fibonacci(const int n)
{
    return n == 1 || n == 2 ? 1 : fibonacci(n - 1) + fibonacci(n - 2); //斐波那契数列
}

int arr[fibonacci(4)] = { 0 };  //声明了一个有3个int元素的数组，每一个元素都是0
```

C++11引入的constexpr关键字只能修饰简单的函数，就是函数实现只能由 return 一行代码。从C++14开始，constexpr函数可以在内部使用局部变量、循环和分支等简单语句，如下代码：

```C++
constexpr int fibonacci(const int n)
{
    if (n == 1)
    {
        return 1;
    }

    if (n == 2)
    {
        return 1;
    }

    return fibonacci(n - 1) + fibonacci(n - 2);
}
```

和上面的那段代码功能一样，逻辑也是一样的，但是在C++11中是跑不了的。

使用constexpr的注意事项：

​1.constexpr 修饰符是将编译期运算的结果变成常量表达式，也就是说 constexpr 修饰的对象也要是一个确定不变的值，最起码需要是 const 修饰的值。如下代码：

```C++
int a = 1, b = 2;
const int c = 1, d = 2;
constexpr int value1 = a + b;  //错误，a 和 b 是变量，无法在编译期计算出常量值
constexpr int value2 = c + d;  //可以，c 和 d 是 const 常量，可以在编译期确定其值
constexpr int value3 = 1 + 2;  //更可以了
```

​2.如果是修饰函数，那么返回值一定不能是void ，也就是说一定要有返回值.

​3.C++11时期的constexpr有诸多限制，函数体通常只有一句 return 语句，函数体内既不能声明变量，也不能使用for语句之类的常规控制流语句。

​4.对于自定义类型(自定义类和自定义结构体)，不能直接用constexpr修饰。正确的做法应该是在该类型的内部添加一个常量构造函数。如下代码：

```C++
struct myType
{
    constexpr myType(string name, int age):m_name(name), m_age(age) {};  //常量构造函数
    string m_name;
    int m_age;
}
```

## 2.2 变量及其初始化

### if/switch 变量声明强化

​在传统C++中，可以在 for 循环内声明一个临时变量 int，但是始终没有办法再 if 和 switch语句中声明一个临时变量。C++17解除了这一限制，使我们可以在 if/switch 中完成这一操作。

```C++
std::vector<int> vec = { 1, 2, 3, 4 };
if (const vector<int>::iterator itr = std::find(vec.begin(), vec.end()), 3; itr != vec.end())
{
 *itr = 4;
}
```

书上的代码样例不是很好，本来挺简单的一个东西，弄得好像有点复杂。

### 初始化列表

初始化是一个非常重要的语言特性，最常见的就是在对象进行初始化的时候调用。在传统C++中，不同的对象有不同的初始化方法。普通数组、POD(Plain Old Data，没有构造、析构和虚函数的类或结构体)类型都可以使用 {} 进行初始化，也就是我们所说的初始化列表。而对于类对象的初始化，要么需要通过拷贝构造、要么就需要用 () 。这些方法都有各自针对的对象，不能通用。

C++11首先把初始化列表绑定到了类型上，称之为 std::initializer_list，允许构造函数或其他函数像参数一样使用初始化列表，这就为类对象初始化与普通数组和POD初始化方法提供了统一的桥梁。

```C++
class Foo
{
public:
    std::vector<int> vec;
    Foo (std::initializer_list<int> list)
    {
        for (std::initializer_list<int>::iterator itr = list.begin(); it != list.end(); ++it)
        {
            vec.emplace
        }
    }
}
```

initializer_list\<T> 采用迭代器的方式访问，但是这种方式还是有一个缺点，如下代码：

```C++
class Student
{
public:
    int age;
    string name;
    Student(int value, string str):age(value), name(str) {}  //可以采用这种方式
}
```

这样，大部分类型的初始化方式，都可以采用统一的方式，如下代码：

```C++
Foo foo = { 1, 2, 3, 4 };
Strdent student = { 18, "Jay" };
```

现代C++中，通过initializer_list\<T> 来实现了初始化的统一。现在，C风格数组、STL容器、自定义对象类型都可以通过统一的方式进行初始化，降低了语言的复杂程度。

### 结构化绑定

结构化绑定提供了类似其他语言中提供的多返回值的功能。C++增加了 std::tuple 容器用于构造一个元组，进而囊括多个返回值。但是，C++11/14 中并没有提供一种简单的方法直接从元组中拿到定义元组的元素，尽管可以使用 std::tid 对元组进行拆包，但是实际上非常麻烦。

C++17提供了结构化绑定这一特性，代码如下：

```C++
tuple<int, double, string> func()
{
    return make_tuple(1, 2, 3, "456");
}

auto [x, y, z] = func();
```

## 2.3 类型推导

在传统C++中，参数的类型必须明确定义，这会很大程度上降低我们的变成速度。尤其是当我们面对一大堆复杂的模板类型时，必须明确指定变量的类型才能继续进行后续的编码。不仅降低开发速度，代码也变得又臭又长

### auto

auto 在很早以前就进入C++了，咱们也不去纠结以前到底干什么用，咱就说说现在有什么用。

使用 auto 进行类型推导的一个最为常见的例子就是迭代器。

```C++
//在 C++11 之前
for (vector<int>::iterator itr = vec.begin(); itr != vec.end(); ++itr)

//使用 auto
for (auto itr = vec.begin(); itr != vec.end(); ++itr)

//一些常见的用法
auto i = 5;  //i 被推导为 int
auto arr = new auto(10);  //arr 被推导为 int *
```

从C++20起，auto 可以被用作函数传参，如下代码：

```C++
int add(auto x, auto y)
{
    return x + y;
}

auto i = 5;  //i 被推导为 int
auto j = 6;  //j 被推导为 int

cout << add(i, j) << endl;
```

注意：auto 还不能用于数组类型的推导，如下代码：

```C++
auto auto_arr2[10] = { arr };  //错误，无法推导数组类型
```

### decltype(表达式)

有时候，我们可能需要计算某个表达式的类型，如下代码：

```C++
auto x = 1;
auto y = 2;
decltype(x + y) z;
```

配合 std::is_same<T, U> 可以判断 T 和 U 两个类型是否相等，如下代码：

```C++
if (is_same<decltype(x), int>::value)
    cout << "type x == int" << endl;  //可以正常输出

if (is_same<decltype(x), float>::value)
    cout << "type x == float" << endl;  //不能输出
```

### 尾返回类型推导

在传统C++中，如下代码：

```C++
template<typename R, typename T, typename U>
R add(T x, U y)
{
    return x + y;
}
```

注意；typename 和 class 在模板参数列表中没有区别，在 typename 这个关键字出现之前，都是使用 class 来定义模板参数的。但在模板中定义有嵌套依赖类型的变量时，需要用 typename 消除歧义。

上面的代码不但丑，而且又很大问题。这个问题是，在调用 add() 函数的时候，我们并不知道他会做些什么，以及会获得一个什么样的返回类型。

其实，这里在传统 C++ 中也可以得到解决，那就是指定参数类型，如下代码：

```C++
cout << add<int, int, int>(1, 2) << endl;
```

在C++11中，你可能会想到使用 decltype 推导 x + y 的类型，如下代码：

```C++
decltype(x + y) add(T x, U y)
```

但是，还是不行，因为在编译期读到 decltype(x + y) 的时候，x 和 y未被定义，无法推导类型。

为了解决上面的那个问题，C++引入了一个叫尾返回类型，利用 atuo 关键字将返回类型后置：

```C++
template<typename T, typename U>
auto add2(T x, U y) -> decltype(x + y)
{
    return x + y;
}
```

上面的代码看起来怪怪的，而且 -> 符号在 C++ 中有其他意义，个人感觉不是非常友好。还好从 C++14 开始，可以直接让普通函数具备返回值类型推导，因此，可以出现下面的写法：

```C++
template<typename T, typename U>
auto add3(T x, U y)
{
    return x + y;
}
```

### decltype(auto)

decltype(auto) 是C++14开始提供的一个比较复杂的用法。这个用法涉及到参数转发的概念，这里先略过，等到说到参数转发的时候补充。

### 类型推导小结

1.类型推导的使用，在保证效率和可读性的前提下适当使用，不要滥用。

2.能够使用类型推导的前提是，你需要提供足够的信息，让编译器可以利用这些信息进行类型推导

## 2.4 控制流

### if constexpr

C++17 将 constexpr 这个关键字引入到 if 语句中，允许代码中声明常量表达式的判断条件，如下代码：

```C++
template<typename T>
auto print_type_info(const T& t)
{
    if constexpr (std::is_integral<T>::value)
    {
        return t + 1;
    }
    else
    {
        return t + 0.001;
    }
}
```

各个特性并不复杂，只是让代码在编译的时候就可以完成分支判断，会有效率上的提升。

### 区间 for 迭代

C++ 终于在 C++ 中引入了基于范围迭代的写法，如下代码：

```C++
vector<int> vec = { 1, 2, 3, 4 };

for (auto element : vec)
{
    cout << element << endl;  //只读
}

for (auto element : vec)
{
    element += 1;  //读写
}
```

## 2.5 模板

C++的模板被称作C++的黑魔法，甚至可以独立作为一门新的语言来进行使用。

模板的哲学在一一切能够在编译期处理的问题全部都丢到编译期进行处理，仅在运行时处理那些最核心的动态服务，进而大幅度优化性能。

### 外部模板

传统C++中，模板只有在使用时才会被编译器实例化。只要在每个编译单元(文件)中遇到了被完整定义的模板，都会实例化。这就产生了重复实例化而导致编译时间增加。并且，我们没有办法通知编译器不要触发模板的实例化。

C++11 引入了外部模板，扩充了原来的强制编译器在特性位置实例化模板的语法，使我们能够显示的通知编译器何时进行模板的实例化。如下代码：

```C++
template class vector<bool>;  //强行实例化
extern template class vector<double>;  //不在当前文件中实例化模板
```

### 尖括号"<"

在传统C++的编译器中，>>一律被当作右移运算符来进行处理。但是，很容易就会出现下面的代码：

```C++
vector<vector<int>> matrix;
```

传统 C++ 编译器下不能通过编译，而从 C++11 开始，连续右尖括号是合法的。甚至，可以写出如下代码：

```C++
template<bool T>
class MagicType
{
    bool magic = T;
};

vector<MagicType<(1 < 2)>> magic;  //合法，但是非常难看，不建议
```

有些代码合法，但是从可读性的角度就是不合理的，要杜绝。除非为了性能考虑，必须写成可读性不好的代码，这种情况非常少。

### 类型别名模板

模板是用来产生类型的。这句话应该是 C++ 模板的核心了。

在传统 C++ 中，typedef 可以为类型定义一个新的名称，但是没有办法为模板定义一个新的名称。因为，模板不是类型。如下代码：

```C++
template<typename T, typename U>
class MagicType
{
public:
    T dark;
    U magic;
};

typedef MagicType<vector<T>, string> FakeDarkMagic;  //不合法
```
通常，使用 typedef 定义别名的语法是：typedef 原名称 新名称；但是对函数指针的别名定义的语法却不一样。

C++11 使用 using 引入了下面的写法：

```C++
typedef int (*process)(void *);
using NewProcess = int(*)(void *);  //和上面的效果一样

using TrueDarkMagic = MagicType<vector<T>, string>;  //合法
```
