# 第二章 语言可用性的强化

## 2.1 常量

### nullptr

目的是为了代替NULL。传统C++会把NULL、0是为一种东西，这取决于编译器如何定义NULL。有些编译器会定义为((void)* 0)，有些会直接定义为0.

C++不允许直接将void *隐式转换到其他类型。如果编译器尝试把NULL定义为((void)* 0)，如下代码：

```C++
char *ch = NULL;
```

由于C++没有 void * 的隐式转换，只好将NULL定义为0。表面上是解决了当前问题，但是这样做会产生重载混乱的新问题，如下代码：

```C++
void foo(char*);
void foo(int);
...
foo(NULL);  //这个函数会调用 foo(int)，不符合直觉，很麻烦
```

C++11引入了nullptr关键字，专门用来区分空指针、0。nullptr的类型为nullptr_t，能够隐式的转换成任何指针或成员指针的类型，也能和它们进行相等或者不相等比较。

所以，作为新时代的C++程序员，请养成使用nullptr的习惯。

### constexpr

C++中数组的长度必须是一个常量表达式，你可以以前通过如下代码也可以定义一个数组：

```c++
const int len = 10;
int arr[len] = { 0 };
```

上面的代码可能在大部分编译器上可以跑，但是其实在C++中这是非法的。如果用古老一点的编译器，是会报错的，但是现在的编译器大部分都做了优化，其实这一点非常的不好。

C++11引入了 constexpr关键字，让用户显示的声明函数或对象构造函数在编译期会成为常量表达式。而且，constexpr可以修饰递归，如下代码：

```C++
constexpr int fibonacci(const int n)
{
    return n == 1 || n == 2 ? 1 : fibonacci(n - 1) + fibonacci(n - 2); //斐波那契数列
}

int arr[fibonacci(4)] = { 0 };  //声明了一个有3个int元素的数组，每一个元素都是0
```

C++11引入的constexpr关键字只能修饰简单的函数，就是函数实现只能由 return 一行代码。从C++14开始，constexpr函数可以在内部使用局部变量、循环和分支等简单语句，如下代码：

```C++
constexpr int fibonacci(const int n)
{
    if (n == 1)
    {
        return 1;
    }

    if (n == 2)
    {
        return 1;
    }

    return fibonacci(n - 1) + fibonacci(n - 2);
}
```

和上面的那段代码功能一样，逻辑也是一样的，但是在C++11中是跑不了的。

使用constexpr的注意事项：

​1.constexpr 修饰符是将编译期运算的结果变成常量表达式，也就是说 constexpr 修饰的对象也要是一个确定不变的值，最起码需要是 const 修饰的值。如下代码：

```C++
int a = 1, b = 2;
const int c = 1, d = 2;
constexpr int value1 = a + b;  //错误，a 和 b 是变量，无法在编译期计算出常量值
constexpr int value2 = c + d;  //可以，c 和 d 是 const 常量，可以在编译期确定其值
constexpr int value3 = 1 + 2;  //更可以了
```

​2.如果是修饰函数，那么返回值一定不能是void ，也就是说一定要有返回值.

​3.C++11时期的constexpr有诸多限制，函数体通常只有一句 return 语句，函数体内既不能声明变量，也不能使用for语句之类的常规控制流语句。

​4.对于自定义类型(自定义类和自定义结构体)，不能直接用constexpr修饰。正确的做法应该是在该类型的内部添加一个常量构造函数。如下代码：

```C++
struct myType
{
    constexpr myType(string name, int age):m_name(name), m_age(age) {};  //常量构造函数
    string m_name;
    int m_age;
}
```

## 2.2 变量及其初始化

### if/switch 变量声明强化

​在传统C++中，可以在 for 循环内声明一个临时变量 int，但是始终没有办法再 if 和 switch语句中声明一个临时变量。C++17解除了这一限制，使我们可以在 if/switch 中完成这一操作。

```C++
std::vector<int> vec = { 1, 2, 3, 4 };
if (const vector<int>::iterator itr = std::find(vec.begin(), vec.end()), 3; itr != vec.end())
{
 *itr = 4;
}
```

书上的代码样例不是很好，本来挺简单的一个东西，弄得好像有点复杂。

### 初始化列表

初始化是一个非常重要的语言特性，最常见的就是在对象进行初始化的时候调用。在传统C++中，不同的对象有不同的初始化方法。普通数组、POD(Plain Old Data，没有构造、析构和虚函数的类或结构体)类型都可以使用 {} 进行初始化，也就是我们所说的初始化列表。而对于类对象的初始化，要么需要通过拷贝构造、要么就需要用 () 。这些方法都有各自针对的对象，不能通用。

C++11首先把初始化列表绑定到了类型上，称之为 std::initializer_list，允许构造函数或其他函数像参数一样使用初始化列表，这就为类对象初始化与普通数组和POD初始化方法提供了统一的桥梁。

```C++
class Foo
{
public:
    std::vector<int> vec;
    Foo (std::initializer_list<int> list)
    {
        for (std::initializer_list<int>::iterator itr = list.begin(); it != list.end(); ++it)
        {
            vec.emplace
        }
    }
}
```

initializer_list\<T> 采用迭代器的方式访问，但是这种方式还是有一个缺点，如下代码：

```C++
class Student
{
public:
    int age;
    string name;
    Student(int value, string str):age(value), name(str) {}  //可以采用这种方式
}
```

这样，大部分类型的初始化方式，都可以采用统一的方式，如下代码：

```C++
Foo foo = { 1, 2, 3, 4 };
Strdent student = { 18, "Jay" };
```

现代C++中，通过initializer_list\<T> 来实现了初始化的统一。现在，C风格数组、STL容器、自定义对象类型都可以通过统一的方式进行初始化，降低了语言的复杂程度。

### 结构化绑定

结构化绑定提供了类似其他语言中提供的多返回值的功能。C++增加了 std::tuple 容器用于构造一个元组，进而囊括多个返回值。但是，C++11/14 中并没有提供一种简单的方法直接从元组中拿到定义元组的元素，尽管可以使用 std::tid 对元组进行拆包，但是实际上非常麻烦。

C++17提供了结构化绑定这一特性，代码如下：

```C++
tuple<int, double, string> func()
{
    return make_tuple(1, 2, 3, "456");
}

auto [x, y, z] = func();
```

## 2.3 类型推导

在传统C++中，参数的类型必须明确定义，这会很大程度上降低我们的变成速度。尤其是当我们面对一大堆复杂的模板类型时，必须明确指定变量的类型才能继续进行后续的编码。不仅降低开发速度，代码也变得又臭又长

### auto

auto 在很早以前就进入C++了，咱们也不去纠结以前到底干什么用，咱就说说现在有什么用。

使用 auto 进行类型推导的一个最为常见的例子就是迭代器。

```C++
//在 C++11 之前
for (vector<int>::iterator itr = vec.begin(); itr != vec.end(); ++itr)

//使用 auto
for (auto itr = vec.begin(); itr != vec.end(); ++itr)

//一些常见的用法
auto i = 5;  //i 被推导为 int
auto arr = new auto(10);  //arr 被推导为 int *
```

从C++20起，auto 可以被用作函数传参，如下代码：

```C++
int add(auto x, auto y)
{
    return x + y;
}

auto i = 5;  //i 被推导为 int
auto j = 6;  //j 被推导为 int

cout << add(i, j) << endl;
```

注意：auto 还不能用于数组类型的推导，如下代码：

```C++
auto auto_arr2[10] = { arr };  //错误，无法推导数组类型
```

### decltype(表达式)

有时候，我们可能需要计算某个表达式的类型，如下代码：

```C++
auto x = 1;
auto y = 2;
decltype(x + y) z;
```

配合 std::is_same<T, U> 可以判断 T 和 U 两个类型是否相等，如下代码：

```C++
if (is_same<decltype(x), int>::value)
    cout << "type x == int" << endl;  //可以正常输出

if (is_same<decltype(x), float>::value)
    cout << "type x == float" << endl;  //不能输出
```
